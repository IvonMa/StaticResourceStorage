四步做题

1. 搞清题目细节，例如输入输出范围
2. 所有解法思考一遍，选出最优解法
3. 写代码
4. 测试



# 算法的时间复杂度

几种复杂度：

O(1), O(n), O(n^2), O(log(n))



常见情况下的复杂度：

二叉树或图的遍历：O(n)

二分查找：O(log(n))

递归求斐波那契数列：O(2^n)



Tips: 斐波那契数列到底应该怎么搞？不要直接递归，要搞个缓存存中间结果，或者用循环。

# 算法的空间复杂度

表示方式：与时间复杂度一致



1. 数组的长度。例如长度为n的数组，空间复杂度就是O(n)
2. 递归的深度。例如深度为n的递归，空间复杂度就是O(n)
3. 又数组又递归的话，就取更大的那个



#### 数组

查询的时间复杂度：O(1)

删除或添加数组元素的时间复杂度：O(n) 因为最差情况下你要移动所有现有元素



#### 链表

查询时间复杂度：O(n)

其他O(1)

应用 LRU Cache

#### 跳表

它需要是有序

所有都是O(log(n))

![YpMej8](https://raw.githubusercontent.com/MA-Aaron/StaticResourceStorage/master/images/2020/09/YpMej8.png)



空间复杂度O(n)

思想：升维+空间换时间

应用：Redis



## 第二课

Queue

* 插入取出都是O(1)

* Java中LikeList其实也是Queue接口的实现类add, remove, offer, poll
* Priority Queue: 插入O1, 但取出变慢成O(log(n)).不过取出可以按优先级了. 底层实现方式就比较多样了，包括堆。Java中要传入一个Comparator

双端队列Deque：头和尾都可以出入。Java中LikeList其实也是Deque接口的实现类. Add, remove, addFirst, removeFirst





## 第4课

之前的都是一位数据结构。然而树和图是二维数据结构。

树：

* 其实是个特殊的图（没有环形结构的图）
* 所有可能出现的情况->展开就是一个树啊。例如棋盘的局势发展。
* 递归展开就是一个树
* 一般解决方案都与递归有关



### 二叉树

遍历

* 一般用递归
  * 前序：**根-左-右**
  * 中序：左-根-右
  * 后序：左-右-根
* 循环是可以，但其实不是很方便
* 完全二叉树：对一个深度为k的二叉树而言，
  * 所有叶子结点都出现在k或k-1层，
  * 且任何节点不能只有左子树而没有右子树（这意味着只有左节点的情况只能出现在最后一层
  * <img src="https://raw.githubusercontent.com/MA-Aaron/StaticResourceStorage/master/images/2020/09/Hik42c.png" alt="Hik42c" style="zoom:50%;" />

### 二叉搜索树（二叉排序树、有序二叉树）

* 特点
  * 所有左子树上的节点值都小于根结点的值
  * 所有右子树上的节点值都大于根结点的值

* 算法复杂度：都是O(log(n))。但如果结构不好，退化成一个链表，那就是O(n)了
* 删除某个根节点怎么办：一般找右子树上与它最接近的节点来做根节点。将其替换到根节点的位置即可



### 堆

* 可以<u>迅速找到一堆数中的最大或最小值</u>的（只能其一）
* 每次找最大值（根结点最大）的堆：大顶堆、大根堆。反之：小顶堆，小根堆。
* 常见实现：二叉堆、斐波那契堆（效果更好一些）。
  * 注意，堆是一种更抽象的数据结构。它的底层实现可以有不同的具体方式。
* 算法复杂度（大顶堆二叉堆为例）
  * 找最大值：O(1)
  * 删除最大值：O(logN)
  * 插入：O(logN)或 O(1)
  * 斐波那契堆只有删除最大值是O(logN)，其他都是O(1)



### 二叉堆

* 通过完全二叉树来实现

  * 注意，完全二叉树不是二叉搜索树。通过二叉搜索树也可以，但是那样的话，找最大最小值就不再是O(1)复杂度了，而是O(logN)

* 性质

  1. 是完全树
  2. 任意节点的值总是>=子节点的值 (所以你可以保证根节点就是最大节点)（注意它不一定从左到右有序）

* 一般通过数组实现

  * 假设第一个元素在数组中索引是0
  * ![lny5RN](https://raw.githubusercontent.com/MA-Aaron/StaticResourceStorage/master/images/2020/09/lny5RN.png)
  * 插入元素的实现
    1. 把新元素放到数组末尾
    2. 每次都跟根节点比较，如果比根结点大，就交换位置。
  * 删除最大元素的实现（其实你删除某个中途元素，也可以套用这个方法。因为它肯定是比自己子树所有节点的值都大）
    1. 将堆尾元素放到堆顶去（你只能挪它，因为这样才能保证依然是一个完全树）
    2. 从上到下依次比较，如果根比<u>两个子中更大的那个</u>要小，就替换

* 注意，二叉堆只是堆的一种简单常见的实现，并不是最优。例如，在Java中要用堆结构的话，就用PriorityQueue。

  

递归

* 找最近重复子问题
* 代码模版
  * ![KmPIt0](https://raw.githubusercontent.com/MA-Aaron/StaticResourceStorage/master/images/2020/09/KmPIt0.png)



分治

![5OhfCJ](https://raw.githubusercontent.com/MA-Aaron/StaticResourceStorage/master/images/2020/09/5OhfCJ.png)



回溯





深度优先搜索（DFS）

* 递归遍历一个数或图，自然就是深度优先搜索

![Kw9OJu](https://raw.githubusercontent.com/MA-Aaron/StaticResourceStorage/master/images/2020/09/Kw9OJu.png)

* 可以用栈去做

```java

public void depthFirst() {
    Stack<Map<String, Object>> nodeStack = new Stack<Map<String, Object>>();
    Map<String, Object> node = new HashMap<String, Object>();
    nodeStack.add(node);
    while (!nodeStack.isEmpty()) {
        node = nodeStack.pop();
        System.out.println(node);
        //获得节点的子节点，对于二叉树就是获得节点的左子结点和右子节点
        List<Map<String, Object>> children = getChildren(node);
        if (children != null && !children.isEmpty()) {
            for (Map child : children) {
                nodeStack.push(child);
            }
        }
    }
}
```





广度优先搜索（BFS）

* 用队列。思路类似于深度优先搜索的用栈来解决的方案。

* 一层一层遍历

* 思路

  * 整个遍历过程如下：

       首先将A节点插入队列中，queue（A）;

       将A节点弹出，同时将A的子节点B，C插入队列中，此时B在队列首，C在队列尾部，queue（B，C）；

       将B节点弹出，同时将B的子节点D，E插入队列中，此时C在队列首，E在队列尾部，queue（C，D，E）;

       将C节点弹出，同时将C的子节点F，G，H插入队列中，此时D在队列首，H在队列尾部，queue（D，E，F，G，H）；

       将D节点弹出，D没有子节点，此时E在队列首，H在队列尾部，queue（E，F，G，H）；

    ```java
    public void breadthFirst() {
        Deque<Map<String, Object>> nodeDeque = new ArrayDeque<Map<String, Object>>();
        Map<String, Object> node = new HashMap<String, Object>();
        nodeDeque.add(node);
        while (!nodeDeque.isEmpty()) {
            node = nodeDeque.poll();
            System.out.println(node);
            //获得节点的子节点，对于二叉树就是获得节点的左子结点和右子节点
            List<Map<String, Object>> children = getChildren(node);
            if (children != null && !children.isEmpty()) {
                for (Map child : children) {
                    nodeDeque.add(child);
                }
            }
        }
    }
    //这里使用的是双端队列，和使用queue是一样的
    
    ```

    

优先级优先搜索（启发式搜索）





贪心算法 Greedy

* 每一步都做当前最好的选择，从而希望得到全局最优
* 它并不是一定真的是全局最优
* 与动态规划的区别
  * 贪心算法对每个子问题的解决方案都做出选择，不能回退
  * 动态规划会<u>记录</u>以前的计算结果，并根据以前的结果对当前进行选择，有<u>回退</u>功能。
* 它一般会作为一个辅助算法。因为
  * 比较高效
  * 一般也比较接近最优解
* 如果要单独用：你要能证明它可以直接得到全局最优解
* 贪心的方向：不一定从头开始，也可能从某一个中间位置，或从结尾开始往前贪心
* 例题
* ![gwGvOu](https://raw.githubusercontent.com/MA-Aaron/StaticResourceStorage/master/images/2020/09/gwGvOu.png)



二分查找

* 条件
  * 函数单调
  * 存在上下届
  * 存在下标
* 思路：关键就是判断什么时候在左边，什么时候在右边。这些条件有时候会泛化，例如在旋转数组那题中就加入了额外条件。
* ![OEK4NF](https://raw.githubusercontent.com/MA-Aaron/StaticResourceStorage/master/images/2020/09/OEK4NF.png)

* 牛顿法 求平方根

  ![hD3aFf](https://raw.githubusercontent.com/MA-Aaron/StaticResourceStorage/master/images/2020/09/hD3aFf.png)

* 一个比较复杂的二分查找
  * https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/ji-jian-solution-by-lukelee/



动态规划

* 与递归或分治没有根本上的区别
* 与上述两者的差异性：动态规划一定存在且最优子结构，中途可以淘汰次优解
* ![Tp1125](https://raw.githubusercontent.com/MA-Aaron/StaticResourceStorage/master/images/2020/09/Tp1125.png)

* [最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/solution/dong-tai-gui-hua-zhi-zui-chang-gong-gong-zi-xu-lie/)

  * 思维总结：两个数组比较，好像都要转化为二维（两个字符串一个做行标一个做列标，然后中间是一些数字）

* 120 三角形最短路径

  * ![u2lEPh](https://raw.githubusercontent.com/MA-Aaron/StaticResourceStorage/master/images/2020/09/u2lEPh.png)

* 最大子序列和

  ![9rpLa6](https://raw.githubusercontent.com/MA-Aaron/StaticResourceStorage/master/images/2020/09/9rpLa6.png)

* [零钱兑换问题](https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-tao-lu-xiang-jie-by-wei-lai-bu-ke/)

* 打家劫舍问题![2PYf2b](https://raw.githubusercontent.com/MA-Aaron/StaticResourceStorage/master/images/2020/09/2PYf2b.png))

* B站搜索：MIT动态规划

* 解决DP的思维路径：5步

  1. 定义子问题（分治）
  2. 猜递推方程（这些子问题怎么解决）
  3. 这些子问题的结果怎么组合成当前层的结果
  4. 递归 & 记忆化
     * 或者把状态表建立起来，然后bottom-up（循环）
  5. 解决最后的总的问题

* 具体一点的思维步骤：

  1. 子问题
  2. 状态定义
  3. DP方程  （状态转移方程）





斐波那契数列的解决方案

* 傻递归
* 带缓存的递归
* 循环，从0开始倒过来算到n （自底向上）（这才是动态规划最好的方式，但思路难一些）